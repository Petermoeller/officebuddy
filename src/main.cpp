
/*
   Office_Buddy version 00.00 Revision 00
   by Peter Moeller,

 */

#include <Arduino.h>

// u8g2 initiating
#include <U8g2lib.h>
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif
U8G2_SSD1306_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// DHT22 Initiating
#include <Adafruit_Sensor.h>
#include <DHT.h>

//DHT22
#define DHTPIN 3         // DHT connected to pin 3
#define DHTTYPE DHT22     // DHT 22  (AM2302)
DHT dht(DHTPIN, DHTTYPE); // Initialize DHT sensor for normal 16mhz Arduino

float DHT22hum;         //DHT22 Stores humidity value
float DHT22temp;        //DHT22 Stores temperature value
float DHT22hi;          //DHT22 Stores Heat Index value

//LDR
const int LDRpin        = A0;        //LDR assigned to A0
int LDRvalue            = 0;           //to store the value coming from the LDR
float LDRvolt           = 0.0;
float LDRres            = 10.0;      //10kOhm pullup
float LDRlux            = 0.0;

// Microphone MAX4466
const int MicSampleWindow = 50;    // Sample window width in mS (50 mS = 20Hz)
const int MicPin          = A1;    // Assigned to pin 3
unsigned int MicSample;
unsigned int peakToPeak   = 0;    // peak-to-peak level


// Button logic
#include <Bounce2.h>
const int nextButton    = 4;
const int selectButton  = 5;
const int prevButton    = 6;

Bounce prevBounce   = Bounce(prevButton, 5);
Bounce nextBounce   = Bounce(nextButton, 5);
Bounce selectBounce = Bounce(selectButton, 5);


// Menu Logic
int numOfScreens        = 4;
int currentScreen       = 0;
byte numOfSubScreens    = 5;
int currentSubScreen    = 0;

// Arrays
float sensorVals [5]    = {0.0, 0.0, 0.0, 0.0, 0.0}; //array to store sensor values for later use
String sensorUnit [5][3]   = {{"Humidity", "%", "HUM"}, {"Temperature", "C", "TEMP"}, {"Heat Index", "C", "HI"}, {"Luminosity", "LX", "Lux"}, {"Volume", "xx", "VOL"}}; //array to store sensor values for later use

/* Bit map pictures */

/*  These xbm's messes with the array values somehow when declared..
 #define tinkr25px_width 73
 #define tinkr25px_height 24
   static unsigned char tinkr25px_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x18, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x3c, 0x00,
   0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x3c, 0x00, 0x00, 0xf0,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x38, 0x00, 0x00, 0xf0, 0x00, 0x00,
   0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f,
   0x18, 0x80, 0x07, 0xf0, 0x40, 0x00, 0x3c, 0x00, 0xfc, 0x1f, 0x3c, 0xf0,
   0x1f, 0xf0, 0xe0, 0x00, 0x7f, 0x00, 0xfc, 0x1f, 0x3c, 0xf8, 0x7f, 0xf0,
   0xf0, 0x81, 0x7f, 0x00, 0x3c, 0x00, 0x3c, 0xfc, 0xff, 0xf0, 0xf8, 0xc0,
   0x3f, 0x00, 0x3c, 0x00, 0x3c, 0x7c, 0xf8, 0xf0, 0x7c, 0xe0, 0x03, 0x00,
   0x3c, 0x00, 0x3c, 0x3e, 0xf0, 0xf1, 0x3f, 0xe0, 0x01, 0x00, 0x3c, 0x00,
   0x3c, 0x1e, 0xe0, 0xf1, 0x1f, 0xf0, 0x00, 0x00, 0x3c, 0x00, 0x3c, 0x1e,
   0xe0, 0xf1, 0x0f, 0xf0, 0x00, 0x00, 0x3c, 0x00, 0x3c, 0x1e, 0xe0, 0xf1,
   0x0f, 0xf0, 0x00, 0x00, 0x3c, 0x00, 0x3c, 0x1e, 0xe0, 0xf1, 0x1f, 0xf0,
   0x00, 0x00, 0x3c, 0x00, 0x3c, 0x1e, 0xe0, 0xf1, 0x3f, 0xf0, 0x00, 0x00,
   0x7c, 0x00, 0x3c, 0x1e, 0xe0, 0xf1, 0x7e, 0xf0, 0x00, 0x00, 0xf8, 0xe0,
   0x3c, 0x1e, 0xe0, 0xf1, 0xfc, 0xf0, 0x00, 0x00, 0xf8, 0xff, 0x3c, 0x1e,
   0xe0, 0xf1, 0xf8, 0xf1, 0x00, 0x00, 0xf0, 0xff, 0x3c, 0x1e, 0xe0, 0xf1,
   0xe0, 0xf1, 0x00, 0x00, 0xe0, 0x7f, 0x3c, 0x0e, 0xc0, 0xf1, 0xc0, 0xf1,
   0x00, 0x00, 0x80, 0x1f, 0x18, 0x0c, 0xc0, 0x60, 0x80, 0x60, 0x00, 0x00 };

 #define tinkr_v00_30px_width 85
 #define tinkr_v00_30px_height 29
   static unsigned char tinkr_v00_30px_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xe0, 0x01, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0xe0,
   0x03, 0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0xe0, 0x03,
   0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0xe0, 0x01, 0x00,
   0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x80, 0x00, 0x00, 0x00,
   0xf0, 0x01, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0x01, 0x00, 0x00, 0x00, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x01,
   0x00, 0x00, 0x00, 0xfe, 0x7f, 0xc0, 0x01, 0xf8, 0x03, 0xf0, 0x01, 0x03,
   0xc0, 0x0f, 0xfe, 0x7f, 0xe0, 0x01, 0xfe, 0x0f, 0xf0, 0xc1, 0x07, 0xf0,
   0x0f, 0xfe, 0x7f, 0xe0, 0x01, 0xff, 0x1f, 0xf0, 0xe1, 0x07, 0xfc, 0x0f,
   0xfe, 0x3f, 0xe0, 0x81, 0xff, 0x3f, 0xf0, 0xf1, 0x07, 0xfc, 0x07, 0x3e,
   0x00, 0xe0, 0xc1, 0x1f, 0x7f, 0xf0, 0xf9, 0x03, 0xfe, 0x00, 0x3e, 0x00,
   0xe0, 0xc1, 0x07, 0xfc, 0xf0, 0xfd, 0x01, 0x3f, 0x00, 0x3e, 0x00, 0xe0,
   0xe1, 0x07, 0xf8, 0xf0, 0xff, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0xe0, 0xe1,
   0x03, 0xf8, 0xf0, 0x7f, 0x80, 0x0f, 0x00, 0x3e, 0x00, 0xe0, 0xe1, 0x03,
   0xf0, 0xf0, 0x3f, 0x80, 0x0f, 0x00, 0x3e, 0x00, 0xe0, 0xe1, 0x03, 0xf0,
   0xf0, 0x1f, 0x80, 0x0f, 0x00, 0x3e, 0x00, 0xe0, 0xe1, 0x01, 0xf0, 0xf0,
   0x3f, 0x80, 0x0f, 0x00, 0x3e, 0x00, 0xe0, 0xe1, 0x01, 0xf0, 0xf0, 0x7f,
   0x80, 0x0f, 0x00, 0x3e, 0x00, 0xe0, 0xe1, 0x01, 0xf0, 0xf0, 0xff, 0x80,
   0x0f, 0x00, 0x7c, 0x00, 0xe1, 0xe1, 0x01, 0xf0, 0xf0, 0xfd, 0x81, 0x0f,
   0x00, 0xfc, 0xc0, 0xe3, 0xe1, 0x01, 0xf0, 0xf0, 0xf1, 0x83, 0x0f, 0x00,
   0xf8, 0xff, 0xe3, 0xe1, 0x01, 0xf0, 0xf0, 0xe1, 0x87, 0x0f, 0x00, 0xf8,
   0xff, 0xe3, 0xe1, 0x01, 0xf0, 0xf0, 0xc1, 0x8f, 0x0f, 0x00, 0xf0, 0xff,
   0xe3, 0xe1, 0x01, 0xf0, 0xf0, 0x81, 0x8f, 0x0f, 0x00, 0xc0, 0xff, 0xe0,
   0xe1, 0x01, 0xf0, 0xf0, 0x00, 0x8f, 0x07, 0x00, 0x00, 0x3f, 0xc0, 0x80,
   0x00, 0x60, 0x40, 0x00, 0x06, 0x02, 0x00 };

 #define ear_symb_small_width 20
 #define ear_symb_small_height 20
   static unsigned char ear_symb_small_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0xc0, 0x30, 0x00, 0x20, 0x40, 0x00,
   0x20, 0xc2, 0x00, 0x00, 0x89, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00,
   0x80, 0x81, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x43, 0x00, 0x80, 0x23, 0x00,
   0x80, 0x23, 0x00, 0x80, 0x11, 0x00, 0x00, 0x10, 0x00, 0x20, 0x08, 0x00,
   0x20, 0x08, 0x00, 0x40, 0x04, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00};

 #define vol1_width 6
 #define vol1_height 10
   static unsigned char vol1_bits[] = {
   0x02, 0x07, 0x0c, 0x1c, 0x18, 0x1c, 0x0c, 0x07, 0x02, 0x00};

 #define Vol2_width 10
 #define Vol2_height 20
   static unsigned char Vol2_bits[] = {
   0x08, 0x00, 0x3c, 0x00, 0x78, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0xc6, 0x01,
   0x8f, 0x01, 0x8c, 0x01, 0x9c, 0x03, 0x9c, 0x03, 0x0c, 0x03, 0x8c, 0x01,
   0x8f, 0x01, 0xc6, 0x01, 0xc0, 0x00, 0xf0, 0x00, 0x78, 0x00, 0x1c, 0x00,
   0x08, 0x00, 0x00, 0x00};

 #define Vol3_width 15
 #define Vol3_height 28
   static unsigned char Vol3_bits[] = {
   0x20, 0x00, 0xf0, 0x00, 0xe0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x18, 0x0e,
   0x38, 0x1c, 0x70, 0x18, 0xe0, 0x38, 0xc0, 0x39, 0x87, 0x31, 0x8e, 0x31,
   0x9c, 0x73, 0x18, 0x63, 0x9c, 0x33, 0x1c, 0x73, 0x8e, 0x31, 0x86, 0x31,
   0xc2, 0x39, 0xe0, 0x18, 0x70, 0x18, 0x38, 0x1c, 0x18, 0x0e, 0x00, 0x07,
   0x80, 0x03, 0xe0, 0x01, 0xe0, 0x00, 0x20, 0x00};
 */
#define ico_bitmap_temp_width 32
#define ico_bitmap_temp_heigth 32
static unsigned char ico_bitmap_temp[]  = {
        0x00, 0xF0, 0x00, 0x00, 0x00, 0xF8, 0x01, 0x00, 0x00, 0x9C, 0x03, 0x00,
        0x00, 0x0C, 0xF3, 0x03, 0x00, 0x0C, 0xF3, 0x03, 0x00, 0x0C, 0x03, 0x00,
        0x00, 0x0C, 0x03, 0x00, 0x00, 0x0C, 0xF3, 0x03, 0x00, 0x0C, 0xF3, 0x03,
        0x00, 0x0C, 0x03, 0x00, 0x00, 0x0C, 0x03, 0x00, 0x00, 0x6C, 0xF3, 0x03,
        0x00, 0x6C, 0xF3, 0x03, 0x00, 0x6C, 0x03, 0x00, 0x00, 0x6C, 0x03, 0x00,
        0x00, 0x6C, 0xE3, 0x03, 0x00, 0x6C, 0xE3, 0x03, 0x00, 0x6E, 0x07, 0x00,
        0x00, 0x6F, 0x0F, 0x00, 0x80, 0xF3, 0x1C, 0x00, 0x80, 0xFD, 0x1B, 0x00,
        0xC0, 0xFD, 0x3B, 0x00, 0xC0, 0xFE, 0x37, 0x00, 0xC0, 0xFE, 0x37, 0x00,
        0xC0, 0xFE, 0x37, 0x00, 0xC0, 0xFE, 0x37, 0x00, 0xC0, 0xFD, 0x3B, 0x00,
        0x80, 0xFD, 0x1B, 0x00, 0x80, 0xF3, 0x1C, 0x00, 0x00, 0x0F, 0x0F, 0x00,
        0x00, 0xFE, 0x07, 0x00, 0x00, 0xF8, 0x01, 0x00,
};

#define big_cloud_bits_width 48
#define big_cloud_bits_height 48
static unsigned char big_cloud_bits[]  = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
        0x00, 0x00, 0x80, 0x80, 0x81, 0x01, 0x00, 0x00, 0x80, 0x01, 0x80, 0x01,
        0x00, 0x00, 0x00, 0x83, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xF6, 0x67, 0x00,
        0x00, 0x00, 0x00, 0xB8, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x60, 0x00,
        0x00, 0x00, 0xFF, 0x0F, 0x60, 0x09, 0x00, 0x80, 0x5F, 0x3F, 0x60, 0x0F,
        0x00, 0xC0, 0x03, 0x78, 0x60, 0x02, 0x00, 0xE2, 0x01, 0xF0, 0x20, 0x00,
        0xC0, 0xEF, 0x00, 0xE0, 0x30, 0x00, 0xE0, 0x7F, 0x00, 0xC0, 0x39, 0x00,
        0xF0, 0x7C, 0x00, 0xC0, 0x49, 0x00, 0x60, 0x38, 0x00, 0x80, 0x61, 0x00,
        0x70, 0x10, 0x00, 0x80, 0xC3, 0x00, 0x70, 0x00, 0x00, 0x80, 0x83, 0x01,
        0xF0, 0x00, 0x00, 0x80, 0x07, 0x00, 0x78, 0x00, 0x00, 0x00, 0x0F, 0x00,
        0x3C, 0x00, 0x1C, 0x00, 0x1E, 0x00, 0x0E, 0x1C, 0x3E, 0x00, 0x38, 0x00,
        0x0E, 0x3E, 0x0F, 0x00, 0x38, 0x00, 0x0E, 0x1F, 0x06, 0x00, 0x30, 0x00,
        0x06, 0x06, 0x27, 0x12, 0x30, 0x00, 0x06, 0x07, 0xFE, 0xFF, 0x30, 0x00,
        0x0E, 0xFE, 0xFE, 0xFF, 0x38, 0x00, 0x1E, 0x7E, 0x00, 0x00, 0x38, 0x00,
        0x3C, 0x00, 0x00, 0x00, 0x1E, 0x00, 0xF8, 0xE1, 0x1F, 0xC0, 0x0F, 0x00,
        0xF0, 0xF1, 0x3F, 0xC0, 0x07, 0x00, 0x80, 0xF1, 0x06, 0xC2, 0x01, 0x00,
        0x00, 0x38, 0x00, 0x07, 0x00, 0x00, 0x00, 0x30, 0x60, 0x12, 0x00, 0x00,
        0x00, 0xF0, 0xC1, 0x3A, 0x00, 0x00, 0x00, 0xE0, 0x21, 0x07, 0x00, 0x00,
        0x00, 0x00, 0x20, 0x27, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x1A, 0x00, 0x00,
        0x00, 0x00, 0x40, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

void intro(){
        u8g2.drawRFrame(2, 2, 125, 20, 3);
        u8g2.setFont(u8g2_font_9x15B_tf );
        u8g2.drawStr(11, 18, "OFFICE BUDDY");
        u8g2.setFont(u8g2_font_5x7_mr);
        u8g2.drawStr(4, 35, "Created 2018-02-25");
        u8g2.drawStr(4, 45, "By      Peter Moeller");
        u8g2.drawStr(4, 55, "Version 00.00");

        //u8g2.drawXBM( 5, 5, tinkr_v00_30px_width, tinkr_v00_30px_height, tinkr_v00_30px_bits);    //xbm messes with the arrays(y?)
        //u8g2.drawXBM( 5, 5, tinkr25px_width, tinkr25px_height, tinkr25px_bits);                   //xbm messes with the arrays(y?)
}

void setup() {

        pinMode(prevButton, INPUT);    //prev
        pinMode(selectButton, INPUT); //select
        pinMode(nextButton, INPUT);   //next

        Serial.begin(9600);

        dht.begin();
        u8g2.begin();
        analogReference(EXTERNAL);

        u8g2.firstPage();            // initiate a start up page
        do {
                intro();
        } while (u8g2.nextPage() );
        delay(2000);
}

void menuToggle () {
        while (prevBounce.update()) {
                if (prevBounce.read() == HIGH) {
                        if (currentScreen == 0) {
                                currentScreen = numOfScreens - 1;
                        } else {
                                currentScreen--;
                        }
                }
        }
        while (nextBounce.update()) {
                if (nextBounce.read() == HIGH) {
                        if (currentScreen == numOfScreens - 1) {
                                currentScreen = 0;
                        } else {
                                currentScreen++;
                        }
                }
        }
        while (selectBounce.update()) {
                if (selectBounce.read() == HIGH) {
                        if (currentSubScreen == numOfSubScreens - 1) {
                                currentSubScreen = 0;
                        } else {
                                currentSubScreen++;
                        }
                }
        }
}

void readSensors() {
        DHT22hum  = dht.readHumidity();
        DHT22temp = dht.readTemperature();
        DHT22hi   = dht.computeHeatIndex(DHT22temp, DHT22hum);

        LDRvalue  = analogRead(LDRpin);
        LDRvolt   = LDRvalue * 3.3 / 1024;
        LDRlux    = 500 / (LDRres * ((3.3 - LDRvolt) / LDRvolt));

        // collect data for 50 mS == 20 Hz
        unsigned long startMillis = millis(); // Start of sample window for MICROHONE
        unsigned int signalMax    = 0;
        unsigned int signalMin    = 1024;

        while (millis() - startMillis < MicSampleWindow)
        {
                MicSample = analogRead(MicPin);

                if (MicSample < 1024) // toss out spurious readings
                {
                        if (MicSample > signalMax)
                        {
                                signalMax = MicSample; // save just the max levels
                        }
                        else if (MicSample < signalMin)
                        {
                                signalMin = MicSample; // save just the min levels
                        }
                }
        }
        peakToPeak = signalMax - signalMin; // max - min = peak-peak amplitude

        // save sensor values in array for later use
        sensorVals[0] = DHT22hum;
        sensorVals[1] = DHT22temp;
        sensorVals[2] = DHT22hi;
        sensorVals[3] = LDRlux;
        sensorVals[4] = peakToPeak;

        delay(50);
}

void drawSlider () {
        u8g2.drawCircle(64 - 3, 60, 2);
        u8g2.drawCircle(64 - 9, 60, 2);
        u8g2.drawCircle(64 + 3, 60, 2);
        u8g2.drawCircle(64 + 9, 60, 2);

        if (currentScreen == 0) {
                u8g2.drawDisc(64 - 9, 60, 2);
        } else if (currentScreen == 1) {
                u8g2.drawDisc(64 - 3, 60, 2);
        } else if (currentScreen == 2) {
                u8g2.drawDisc(64 + 3, 60, 2);
        } else if (currentScreen == 3) {
                u8g2.drawDisc(64 + 9, 60, 2);
        }

}

void drawHSlider () {
        u8g2.drawCircle(120, 22, 2);
        u8g2.drawCircle(120, 28, 2);
        u8g2.drawCircle(120, 34, 2);
        u8g2.drawCircle(120, 40, 2);
        u8g2.drawCircle(120, 46, 2);

        if (currentSubScreen == 0) {
                u8g2.drawDisc(120, 22, 2);
        } else if (currentSubScreen == 1) {
                u8g2.drawDisc(120, 28, 2);
        } else if (currentSubScreen == 2) {
                u8g2.drawDisc(120, 34, 2);
        } else if (currentSubScreen == 3) {
                u8g2.drawDisc(120, 40, 2);
        } else if (currentSubScreen == 4) {
                u8g2.drawDisc(120, 46, 2);
        }
}

void drawNoiseIndicator() {
        int noiceWeidth = map(peakToPeak, 0, 1023, 0, 114); //map the value to fit the box weidth

        int xFrame = 4; //frame dimensions
        int yFrame = 15;
        int wFrame = 120;
        int hFrame= 16;

        u8g2.drawFrame(xFrame, yFrame, wFrame, hFrame);
        u8g2.drawBox(xFrame+3, yFrame+3, noiceWeidth, hFrame-6);

        int xVl = xFrame;
        int yVl = yFrame+hFrame+2;
        for (int i = 0; i <= wFrame/10; i++) {
                u8g2.drawVLine(xVl, yVl, 3);
                xVl += 10;

        }
        u8g2.setFont(u8g2_font_9x15B_tf );
        u8g2.drawStr(15, yFrame-5, "NOICE GUARD");

        u8g2.setFont(u8g2_font_6x10_mr);    //7px
        u8g2.setCursor(20, 45); u8g2.print(noiceWeidth);
        u8g2.setCursor(20, 55); u8g2.print(peakToPeak);
}


void drawScreen1() {
        drawSlider();

        u8g2.drawXBM( 1, 10, ico_bitmap_temp_heigth, ico_bitmap_temp_width, ico_bitmap_temp);

        u8g2.setFont(u8g2_font_6x10_mr);    //7px
        u8g2.drawStr(32, 15, "HUM");
        u8g2.drawStr(32, 30, "TEMP");
        u8g2.drawStr(32, 45, "*HI*");

        u8g2.setCursor(110, 15); u8g2.print(sensorUnit[0][1]); //0xC2 0xB0  degree symbol in hex
        u8g2.setCursor(110, 30); u8g2.print(sensorUnit[1][1]);
        u8g2.setCursor(110, 45); u8g2.print(sensorUnit[2][1]);

        u8g2.setFont(u8g2_font_9x18_mr);    //10px
        u8g2.setCursor(60, 15); u8g2.print(sensorVals[0]);
        u8g2.setCursor(60, 30); u8g2.print(sensorVals[1]);
        u8g2.setCursor(60, 45); u8g2.print(sensorVals[2]);
}


void drawScreen2() {
        drawSlider();

        u8g2.drawXBM( 85, 1, big_cloud_bits_width, big_cloud_bits_height, big_cloud_bits);

        u8g2.setFont(u8g2_font_6x10_mr);                    //7px
        u8g2.drawStr(10, 10, "TEMPERATURE");
        u8g2.drawStr(5, 40, "* HUM  *  LUX *");
        u8g2.setCursor(5, 50); u8g2.print(sensorVals[0]); u8g2.setCursor(36, 50); u8g2.print(sensorUnit[0][1]);
        u8g2.setCursor(55, 50); u8g2.print(sensorVals[3]); u8g2.setCursor(67, 50); u8g2.print(sensorUnit[3][1]);

        u8g2.setFont(u8g2_font_9x18_mr);                  //10px
        u8g2.setCursor(20, 25); u8g2.print(sensorVals[1]); u8g2.setCursor(68, 25); u8g2.print(sensorUnit[2][1]); //TEMP
}

void drawScreen3() {

        drawSlider();
        drawHSlider ();

        int x1 = 10; // xy for sensor header
        int y1 = 10; // xy for sensor header
        int x2 = 8; // xy for sensor Value
        int y2 = 20; // xy for sensor Value

        for (int i = 0; i <= numOfSubScreens - 1; i++) {
                if (sensorVals[i] != sensorVals[currentSubScreen] ) {
                        u8g2.setFont(u8g2_font_5x7_mr ); // 5 px
                        u8g2.setCursor( x1,  y1); u8g2.print(sensorUnit[i][2]);
                        u8g2.setCursor( x2,  y2); u8g2.print(sensorVals[i], 1);
                        y1 += 20;
                        y2 += 20;
                }

        }

        u8g2.drawRFrame(1, 1, 35, 63, 3);

        u8g2.setFont( u8g2_font_fub20_tn );
        u8g2.setCursor(40, 42);  u8g2.print(sensorVals[currentSubScreen], 1);

        u8g2.setFont(u8g2_font_helvB08_tr );
        u8g2.setCursor(44, 12);  u8g2.print(sensorUnit[currentSubScreen][0]);// print out the sensor name
        u8g2.setCursor(115, 12); u8g2.print(sensorUnit[currentSubScreen][1]); // print out sensor unit
}

void drawScreen4() {
        drawSlider();

        //u8g2.drawXBM( 50, 25, tinkr25px_width, tinkr25px_height, tinkr25px_bits);

        drawNoiseIndicator();

}


void screenMenu1() {
        readSensors();
        u8g2.firstPage();
        do {
                drawScreen1();
        } while (u8g2.nextPage() );
        delay(5);
}

void screenMenu2() {
        readSensors();
        u8g2.firstPage();
        do {
                drawScreen2();
        } while (u8g2.nextPage() );
        delay(5);
}

void screenMenu3() {
        readSensors();
        u8g2.firstPage();
        do {
                drawScreen3();
        } while (u8g2.nextPage() );
        delay(5);
}

void screenMenu4() {
        readSensors();
        u8g2.firstPage();
        do {
                drawScreen4();
        } while (u8g2.nextPage() );
        delay(5);
}


void loop() {
        switch (currentScreen) {
        case 0:
                screenMenu1();
                menuToggle();
                break;
        case 1:
                screenMenu2();
                menuToggle();
                break;
        case 2:
                screenMenu3();
                menuToggle();
                break;
        case 3:
                screenMenu4();
                menuToggle();
                break;
        }
}
